








































































































































































































































































































































































































































"""0
def ideal_fsc(n,a,N,B,g):
	#  Note number of image N and scaling factor for SSNR are equivalent
	o=[]
	for i in xrange(n/2):
		s=float(i)/n/a
		#  For 2D float(i) has to be replaced by 1.0.
		o.append(N*exp(-B*s*s/4.)/(N*exp(-B*s*s/4.)+float(i)/g))
	return o

def difsc(args,data):
	z=ideal_fsc(360,1.34,50000,args[0],args[1])
	vv = 0.0
	for l in xrange(len(z)):
		vv -= (data[0][l] - z[l])**2
	sxprint(args,vv)
	return vv

##amoeba(arg, [1.0,0.1], difsc, data=data)
##z=ideal_fsc(360,1.34,50000,202.,.05);write_text_file(z,"zz.txt")
"""




















































































































































































































































"""1
		for i in xrange(800):
			ff = freq+(i-400)*0.00002
			print  ff,Util.tf(defocus, ff, voltage, Cs, 10., 0.0, 1.0)
		"""

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































'''2
def adaptive_mask2D(img, nsigma = 1.0, ndilation = 3, kernel_size = 11, gauss_standard_dev =9):
	"""
		Name
			adaptive_mask - create a mask from a given image.
		Input
			img: input image
			nsigma: value for initial thresholding of the image.
		Output
			mask: The mask will have values one, zero, with Gaussian smooth transition between two regions.
	"""
	from sp_utilities  import gauss_edge, model_circle
	from sp_morphology import binarize, dilation
	nx = img.get_xsize()
	ny = img.get_ysize()
	mc = model_circle(nx//2, nx, ny) - model_circle(nx//3, nx, ny)
	s1 = Util.infomask(img, mc, True)
	mask = Util.get_biggest_cluster(binarize(img, s1[0]+s1[1]*nsigma))
	for i in range(ndilation):   mask = dilation(mask)
	#mask = gauss_edge(mask, kernel_size, gauss_standard_dev)
	return mask
'''









'''3
	from sp_utilities import model_blank
	from math import cos, sqrt, pi
	nx = im.get_xsize()
	ny = im.get_ysize()
	nz = im.get_zsize()
	if(radius < 0):
		if(ny == 1):    radius = nx//2 - cosine_width
		elif(nz == 1):  radius = min(nx,ny)//2 - cosine_width
		else:           radius = min(nx,ny,nz)//2 - cosine_width
	radius_p = radius + cosine_width
	om = im.copy()
	cz = nz//2
	cy = ny//2
	cx = nx//2
	if bckg:
		for z in xrange(nz):
			tz = (z-cz)**2
			for y in xrange(ny):
				ty = tz + (y-cy)**2
				for x in xrange(nx):
					r = sqrt(ty + (x-cx)**2)
					if(r > radius_p):
						om.set_value_at_fast(x,y,z, bckg.get_value_at(x,y,z))
					elif(r>=radius):
						temp = (0.5 + 0.5 * cos(pi*(radius_p - r)/cosine_width ))
						om.set_value_at_fast(x,y,z, om.get_value_at(x,y,z) + temp*(bckg.get_value_at(x,y,z)-om.get_value_at(x,y,z)))
	else:
		u = 0.0
		s = 0.0
		for z in xrange(nz):
			tz = (z-cz)**2
			for y in xrange(ny):
				ty = tz + (y-cy)**2
				for x in xrange(nx):
					r = sqrt(ty + (x-cx)**2)
					if(r > radius_p):
						u += 1.0
						s += om.get_value_at(x,y,z)
					elif(r>=radius):
						temp = (0.5 + 0.5 * cos(pi*(radius_p - r)/cosine_width ))
						u += temp
						s += om.get_value_at(x,y,z)*temp
		s /= u
		for z in xrange(nz):
			tz = (z-cz)**2
			for y in xrange(ny):
				ty = tz + (y-cy)**2
				for x in xrange(nx):
					r = sqrt(ty + (x-cx)**2)
					if(r > radius_p):
						om.set_value_at_fast(x,y,z, s)
					elif(r>=radius):
						temp = (0.5 + 0.5 * cos(pi*(radius_p - r)/cosine_width ))
						om.set_value_at_fast(x,y,z, om.get_value_at(x,y,z) + temp*(s-om.get_value_at(x,y,z)))
						#om.set_value_at_fast(x,y,z, om.get_value_at(x,y,z)*(0.5 + 0.5 * cos(pi*(radius_p - r)/cosine_width )))
	return om
	"""
'''









































































































"""4
def refine_with_mask(vol):
	from sp_filter     import filt_dilation
	from sp_utilities  import model_circle, model_gauss, drop_image
	from sp_morphology import collapse
	# does not seem to be working all that well
	nx = vol.get_xsize()
	outer_radius = nx/2-2
	inner_radius = nx/2-4
	outer_sphere = model_circle(outer_radius, nx, nx, nx)
	inner_sphere = model_circle(inner_radius, nx, nx, nx)
	shell = outer_sphere - inner_sphere
	avg,sigma,amin,amax = Util.infomask(vol, shell, False)
	print  avg,sigma,amin,amax
	vol -= avg
	mask = collapse(vol, -1.5*sigma, 1.5*sigma)
	#from utilities import drop_image
	#drop_image(mask,"m1.spi","s")
	mask -= 1.0
	mask *= -1.0

	att = model_circle(1,3,3,3)
	mask = filt_dilation(filt_dilation(filt_dilation(mask, att, "BINARY"), att, "BINARY"), att, "BINARY")

	gauss = model_gauss(2.0, 9, 9, 9)
	avg,sigma,amin,amax = Util.infomask(gauss, None, False)
	gauss /= (avg*9*9*9)
	mask = rsconvolution(mask, gauss)
	#drop_image(mask,"m2.spi","s")
	vol *= mask
	return vol
"""













"""5
	if (idx_freq_min < 0):
		ERROR("compute_bfactor", "Invalid value of idx_freq_min. Setting to 0", 0)
		idx_freq_min = 0
	if (idx_freq_max >= nr):
		pERROR("compute_bfactor", "Invalid value of idx_freq_max. Setting to %d" % (nr - 1), 0)
		idx_freq_max = (nr - 1)
	"""




























































"""6
	Arguments
		input_image_path  :  file name pattern for Micrographs Modes (e.g. 'Micrographs/mic*.mrc') or particle stack file path for Stack Mode (e.g. 'bdb:stack'; must be stack_mode = True).
		output_directory  : output directory
	"""












































































































































































































































































































































































































































































































































































































"""7
			hi = hist_list(sroo,2)
			# hi[0][1] is the threshold
			for i in xrange(1,len(sroo)):
				if(sroo[i] < hi[0][1]):
					istart = i
					break
			"""




































































"""8
				data = [qse, mask, wn, bamp, Cs, voltage, pixel_size, wgh, bang]
				#astdata = [crefim, numr, wn, bdef, Cs, voltage, pixel_size, wgh, bang]
				for qqq in xrange(200):
					qbdef = 1.0 + qqq*0.001
					print " VALUE AT THE BEGGINING OF while LOOP  ",qbdef,simctf2(qbdef, data)#,fastigmatism3(bamp,astdata)
				"""
"""9
				bamp = 0.7
				bang = 37.0
				
				data = [qse, mask, wn, bamp, Cs, voltage, pixel_size, wgh, bang]
				astdata = [crefim, numr, wn, bdef, Cs, voltage, Pixel_size, wgh, bang]
				print " VALUE AT THE BEGGINING OF while LOOP  ",bdef,bamp,bang,simctf2(bdef, data),fastigmatism3(bamp,astdata,mask)
				#print  simctf2out(1.568,data)
				#exit()
				
				for kdef in xrange(14000,17000,10):
					dz = kdef/10000.0
					ard = [qse, mask, wn, bamp, Cs, voltage, pixel_size, wgh, bang]
					#print ard
					aqd = [crefim, numr, wn, dz, Cs, voltage, pixel_size, wgh, bang]
					#print aqd
					print  dz,simctf2(dz,ard),fastigmatism3(bamp,aqd,mask)
					#print aqd[-1]
				exit()
				"""













"""10
				crot2 = rotavg_ctf(ctf2_rimg(wn,generate_ctf([bdef, Cs, voltage, pixel_size, 0.0, wgh, bamp, bang])), bdef, Cs, voltage, pixel_size, bamp, bang)
				pwrot = rotavg_ctf(qa-bckg, bdef, Cs, voltage, pixel_size, bamp, bang)
				write_text_file([range(len(subroo)),asubroo, ssubroo, sen, pwrot, crot2],"rotinf%04d.txt"%ifi)
				qse.write_image("qse.hdf")
				mask.write_image("mask.hdf")
				exit()
				"""


















































































































































































"""11
				for i in xrange(len(ssubroo)):
					asubroo[i] /= kboot
					ssubroo[i]  = sqrt(max(0.0, ssubroo[i]-kboot*asubroo[i]**2)/kboot)
					sen[i]     /= kboot
				"""

























































































































































"""12
	Arguments
		input_image_path  :  file name pattern for Micrographs Modes (e.g. 'Micrographs/mic*.mrc') or particle stack file path for Stack Mode (e.g. 'bdb:stack'; must be stack_mode = True).
		output_directory  : output directory
	"""










































































































































































































































































































































































































































































































































































































"""13
			hi = hist_list(sroo,2)
			# hi[0][1] is the threshold
			for i in xrange(1,len(sroo)):
				if(sroo[i] < hi[0][1]):
					istart = i
					break
			"""



































































"""14
				data = [qse, mask, wn, bamp, Cs, voltage, pixel_size, wgh, bang]
				#astdata = [crefim, numr, wn, bdef, Cs, voltage, pixel_size, wgh, bang]
				for qqq in xrange(200):
					qbdef = 1.0 + qqq*0.001
					print " VALUE AT THE BEGGINING OF while LOOP  ",qbdef,simctf2(qbdef, data)#,fastigmatism3(bamp,astdata)
				"""
"""15
				bamp = 0.7
				bang = 37.0
				
				data = [qse, mask, wn, bamp, Cs, voltage, pixel_size, wgh, bang]
				astdata = [crefim, numr, wn, bdef, Cs, voltage, Pixel_size, wgh, bang]
				print " VALUE AT THE BEGGINING OF while LOOP  ",bdef,bamp,bang,simctf2(bdef, data),fastigmatism3(bamp,astdata,mask)
				#print  simctf2out(1.568,data)
				#exit()
				
				for kdef in xrange(14000,17000,10):
					dz = kdef/10000.0
					ard = [qse, mask, wn, bamp, Cs, voltage, pixel_size, wgh, bang]
					#print ard
					aqd = [crefim, numr, wn, dz, Cs, voltage, pixel_size, wgh, bang]
					#print aqd
					print  dz,simctf2(dz,ard),fastigmatism3(bamp,aqd,mask)
					#print aqd[-1]
				exit()
				"""











"""16
				crot2 = rotavg_ctf(ctf2_rimg(wn,generate_ctf([bdef, Cs, voltage, pixel_size, 0.0, wgh, bamp, bang])), bdef, Cs, voltage, pixel_size, bamp, bang)
				pwrot = rotavg_ctf(qa-bckg, bdef, Cs, voltage, pixel_size, bamp, bang)
				write_text_file([range(len(subroo)),asubroo, ssubroo, sen, pwrot, crot2],"rotinf%04d.txt"%ifi)
				qse.write_image("qse.hdf")
				mask.write_image("mask.hdf")
				exit()
				"""





















































































































































































"""17
				for i in xrange(len(ssubroo)):
					asubroo[i] /= kboot
					ssubroo[i]  = sqrt(max(0.0, ssubroo[i]-kboot*asubroo[i]**2)/kboot)
					sen[i]     /= kboot
				"""
































































































































































































































































































































'''18
	from sp_utilities import info
	print  info(data2d[1], data2d[10])
	print  info(ct, data2d[10])
	print q1,q2
	'''































'''19
	print  info(data2d[1], data2d[10])
	print  info(ct, data2d[10])
	'''





































































































"""20
			def1, def2 = bracket_def(simpw1d, data, def1, h)
			if(def1 > def2):
				temp = def1
				def1 = def2
				def2 = temp
			print "adjusted bracket ",def1, def2,simpw1d(def1, data)
			"""













"""21
	def1 = 0.02
	def2 = 10.
	def1, def2 = goldsearch_astigmatism(simpw1d, data, def1, def2, tol=1.0e-3)
	print "golden ",def1, def2,simpw1d(def1, data)
	"""

























































































"""22
			def1, def2 = bracket_def(simpw1d, data, def1, h)
			if(def1 > def2):
				temp = def1
				def1 = def2
				def2 = temp
			print "adjusted bracket ",def1, def2,simpw1d(def1, data)
			"""













"""23
	def1 = 0.02
	def2 = 10.
	def1, def2 = goldsearch_astigmatism(simpw1d, data, def1, def2, tol=1.0e-3)
	print "golden ",def1, def2,simpw1d(def1, data)
	"""



































































'''24
def defocusgett_(roo, voltage=300.0, Pixel_size=1.0, Cs=2.0, wgh=0.1, f_start=0.0, f_stop=-1.0, round_off=1.0, nr1=3, nr2=6, parent=None):
	"""
		1. Estimate envelope function and baseline noise using constrained simplex method
		   so as to extract CTF imprints from 1D power spectrum
		2. Based one extracted ctf imprints, perform exhaustive defocus searching to get 
		   defocus which matches the extracted CTF imprints 
	"""
	from sp_utilities  import generate_ctf
	from sp_morphology import defocus_env_baseline_fit, defocus_guess, ctf_2, defocus_guessn
	
	#print "CTF params:", voltage, Pixel_size, Cs, wgh, f_start, f_stop, round_off, nr1, nr2, parent

	defocus = defocus_guessn(roo, voltage, Cs, Pixel_size, wgh, f_start)

	nx  = int(len(roo)*2)
	#ctf = ctf_1d(nx, generate_ctf([defocus, Cs, voltage, Pixel_size, 0.0, wgh]))
	ctf2 = ctf_2(nx, generate_ctf([defocus, Cs, voltage, Pixel_size, 0.0, wgh]))
	"""
	if (parent is not None):
		parent.ctf_data=[roo, Res_roo, Res_TE]
		parent.i_start = i_start
		parent.i_stop  = i_stop
		from sp_utilities import write_text_file
		write_text_file([range(len(roo)), roo, Res_roo, Res_TE, ctf], "procpw.txt")
	else:
		from sp_utilities import write_text_file
		write_text_file([range(len(roo)), roo, Res_roo, Res_TE, ctf, TE, Pn1], "procpw.txt")
	"""
	return defocus, [], ctf2, [],[],0,0
'''









































































































"""25
def fastigmatism2(amp, data):
	
	from sp_morphology import ctf_rimg
	from sp_utilities import generate_ctf
	from sp_alignment import ornq
	
	cnx = data[2]//2+1
	#qt = 0.5*nx**2
	pc = ctf_rimg(data[2], generate_ctf([data[3], data[4], data[5], data[6], 0.0, data[7], amp, 0.0]) )
	ang, sxs, sys, mirror, peak = ornq(pc, crefim, 0.0, 0.0, 1, "H", numr, cnx, cnx)# shold be data[0]
	data[-1] = ang
	return  -peak
"""









































































































































































"""26
	#  THIS COULD ALSO WORK< TRY IT
	rot2 = [0.0]*len(roo)
	for i in xrange(len(roo)):  rot2[i] = abs(roo[i])
	TE  = defocus_env_baseline_fit(rot2, i_start, i_stop, int(nr1), 4)  # This does envelope
	"""


















































"""27
	def1 = 0.02
	def2 = 10.
	def1, def2 = goldsearch_astigmatism(simpw1d, data, def1, def2, tol=1.0e-3)
	print "golden ",def1, def2,simpw1d(def1, data)
	"""








































"""28
	#  THIS COULD ALSO WORK< TRY IT
	rot2 = [0.0]*len(roo)
	for i in xrange(len(roo)):  rot2[i] = abs(roo[i])
	TE  = defocus_env_baseline_fit(rot2, i_start, i_stop, int(nr1), 4)  # This does envelope
	"""




































































































































"""29
				sroo[0] = sroo[1]
				aroo[0] = aroo[1]
				sroo = (sroo-aroo**2/nimi)/nimi
				aroo /= nimi
				roo  /= nimi
				qa /= nimi
				"""


























































"""30
				en = envelope.tolist()
				en.append(en[-1])
				envl = model_blank(nx, nx, 1, 1.0)
				for i in xrange(nx):
					for j in xrange(nx):
						r = sqrt((i-nc)**2 + (j-nc)**2)
						ir = int(r)
						if(ir<nc):
							dr = r - ir
							envl.set_value_at(i,j,  (1.-dr)*en[ir] + dr*en[ir+1] )
				"""




























"""31
				astdata = [crefim, numr, nx, 1.1, Cs, voltage, Pixel_size, wgh, 0.]
				junk = fastigmatism2(0.5,astdata)
				bang = astdata[-1]
				print "   IHIHIHIHIHI   ",bang,junk
				#exit()
				"""





























































































"""32
				for i in xrange(len(ssubroo)):
					asubroo[i] /= kboot
					ssubroo[i]  = sqrt(max(0.0, ssubroo[i]-kboot*asubroo[i]**2)/kboot)
					sen[i]     /= kboot
				"""














































"""33
	Arguments
		input_image_path  :  file name pattern for Micrographs Modes (e.g. 'Micrographs/mic*.mrc') or particle stack file path for Stack Mode (e.g. 'bdb:stack'; must be stack_mode = True).
		output_directory  : output directory
	"""











































































































































































































































































































































































































































































































































































































"""34
			hi = hist_list(sroo,2)
			# hi[0][1] is the threshold
			for i in xrange(1,len(sroo)):
				if(sroo[i] < hi[0][1]):
					istart = i
					break
			"""







'''35
				freq = range(len(subpw))
				for i in xrange(len(freq)):  freq[i] = float(i) / wn / pixel_size
				#write_text_file([freq, subpw.tolist(), ctf2, envelope.tolist(), baseline.tolist()], "%s/ravg%05d.txt" % (output_directory, ifi))
				#fou = os.path.join(outravg, "%s_ravg_%02d.txt" % (img_basename_root, nboot))
				fou = os.path.join(".", "%s_ravg_%02d.txt" % (img_basename_root, nboot))
				write_text_file([freq, subpw.tolist(), ctf2, envelope.tolist(), baseline.tolist()], fou)
				'''












































'''36
				freq = range(len(subpw))
				for i in xrange(len(freq)):  freq[i] = float(i) / wn / pixel_size
				#write_text_file([freq, subpw.tolist(), ctf2, envelope.tolist(), baseline.tolist()], "%s/ravg%05d.txt" % (output_directory, ifi))
				#fou = os.path.join(outravg, "%s_ravg_%02d.txt" % (img_basename_root, nboot))
				fou = os.path.join(".", "%s_ravg22_%02d.txt" % (img_basename_root, nboot))
				write_text_file([freq, subpw.tolist(), ctf2, envelope.tolist(), baseline.tolist()], fou)
				'''




































































"""37
			valid_min_defocus = 0.05
			if ad1 < valid_min_defocus:
				reject_img_messages.append("    - Defocus (%f) is smaller than valid minimum value (%f)." % (ad1, valid_min_defocus))
			"""




















































































"""38
				for i in xrange(len(ssubroo)):
					asubroo[i] /= kboot
					ssubroo[i]  = sqrt(max(0.0, ssubroo[i]-kboot*asubroo[i]**2)/kboot)
					sen[i]     /= kboot
				"""


























'''39
				is_peak_target = True
				pre_crot2_val = crot2[0]
				extremum_counts = 0
				extremum_diff_sum = 0
				for i in xrange(1, len(crot2)):
					cur_crot2_val = crot2[i]
					if is_peak_target == True and pre_crot2_val > cur_crot2_val:
						# peak search state
						extremum_i = i - 1
						extremum_counts += 1
						extremum_diff_sum += pwrot2[extremum_i] - pwrot1[extremum_i] # This should be positive if astigmatism estimation is good
						# print "MRK_DEBUG: Peak Search  : extremum_i = %03d, freq[extremum_i] = %12.5g, extremum_counts = %03d, (pwrot2[extremum_i] - pwrot1[extremum_i]) = %12.5g, extremum_diff_sum = %12.5g " % (extremum_i, freq[extremum_i] , extremum_counts, (pwrot2[extremum_i] - pwrot1[extremum_i]), extremum_diff_sum)
						is_peak_target = False
					elif is_peak_target == False and pre_crot2_val < cur_crot2_val:
						# trough search state
						extremum_i = i - 1
						extremum_counts += 1
						extremum_diff_sum += pwrot1[extremum_i] - pwrot2[extremum_i] # This should be positive if astigmatism estimation is good
						# print "MRK_DEBUG: Trough Search: extremum_i = %03d, freq[extremum_i] = %12.5g, extremum_counts = %03d, (pwrot1[extremum_i] - pwrot2[extremum_i]) = %12.5g, extremum_diff_sum = %12.5g " % (extremum_i, freq[extremum_i] , extremum_counts, (pwrot1[extremum_i] - pwrot2[extremum_i]), extremum_diff_sum)
						is_peak_target = True
					pre_crot2_val = cur_crot2_val
				'''


































































































































































































































'''40
	from sp_utilities import write_text_file
	foki = subpw.tolist()
	write_text_file([foki,ctf2[:len(foki)]],"toto1.txt")
	'''














































'''41

	dp = 1.0e23
	toto = []

	for aa in xrange(0,20,5):
		a = xampcont + aa - 10.
		print "  fdasfdsfa  ",a
		for i in xrange(0,2000,500):
			dc = xdefc + float(i-1000)/10000.0
			ju1 = dc # defocus
			ju2 = float(a) # amp contrast
			ju3 = 0.0  # astigma amp
			dama = amoeba([ju1,ju2,ju3], [0.1, 2.0, 0.05], fupw_vpp, 1.e-4, 1.e-4, 500, astdata)
			qma = -dama[-2]
			print  " amoeba  %7.2f  %7.2f  %12.6g  %12.6g"%(dama[0][0],dama[0][1],dama[0][2],qma)
			toto.append([dama[0][0],dama[0][1],dama[0][2],qma])
			if(qma<dp):
				dp = qma
				dpefi = dama[0][0]
				dpmpcont = dama[0][1]
				dastamp = dama[0][2]
				astdata = [crefim, numr, wn, dpefi, Cs, voltage, Pixel_size, dpmpcont, dastamp, bang]
				junk = fastigmatism3_vpp(dama[0][2], astdata)
				dastang = astdata[8]
				print " FOUND ANGLE",junk, qma, dpefi,dpmpcont,dastamp,dastang
		#from sys import exit
		#exit()
	'''


















































































































































































'''42
	#for a in xrange(0,101,10):
	for a in xrange(20,21,10):
		data[7] = float(a)
		print "  fdasfdsfa  ",a
		#for i in xrange(1000,100000,50):
		for i in xrange(5000,5001,5):
			dc = float(i)/10000.0
			qt,ct1 = simpw1dc(dc, data)
			write_text_file(ct1,"testi1.txt")
			write_text_file(data[0],"testd1.txt")
			ju1 = dc # defocus
			ju2 = float(a) # amp contrast
			ju3 = 0.0  # astigma amp
			#dama = amoeba([ju1,ju2,ju3], [0.02, 1.0, 0.02], fupw_vpp, 1.e-4, 1.e-4, 1, astdata)
			data2d[7] = float(a)
			zigi,ct2 = simpw2dc(dc, data2d)
			ct2.write_image("testi2.hdf")
			data2d[1].write_image("testd2.hdf")
			#print  dc,data[7],qt,dama
			toto.append([dc,data[7],qt,zigi])#,dama[-2]])
	'''
















































'''43
	from sp_utilities import write_text_file
	foki = subpw.tolist()
	write_text_file([foki,ctf2[:len(foki)]],"toto1.txt")
	'''
















































































'''44
	#for a in xrange(0,101,10):
	for a in xrange(20,21,10):
		data[7] = float(a)
		print "  fdasfdsfa  ",a
		#for i in xrange(1000,100000,50):
		for i in xrange(5000,5001,5):
			dc = float(i)/10000.0
			qt,ct1 = simpw1dc(dc, data)
			write_text_file(ct1,"testi1.txt")
			write_text_file(data[0],"testd1.txt")
			ju1 = dc # defocus
			ju2 = float(a) # amp contrast
			ju3 = 0.0  # astigma amp
			#dama = amoeba([ju1,ju2,ju3], [0.02, 1.0, 0.02], fupw_vpp, 1.e-4, 1.e-4, 1, astdata)
			data2d[7] = float(a)
			zigi,ct2 = simpw2dc(dc, data2d)
			ct2.write_image("testi2.hdf")
			data2d[1].write_image("testd2.hdf")
			#print  dc,data[7],qt,dama
			toto.append([dc,data[7],qt,zigi])#,dama[-2]])
	'''















































'''45
	from sp_utilities import write_text_file
	foki = subpw.tolist()
	write_text_file([foki,ctf2[:len(foki)]],"toto1.txt")
	'''











